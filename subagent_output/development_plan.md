# План разработки VS Code расширения "Changes Viewer"

## Общая информация

**Проект:** VS Code расширение для локальной истории изменений файлов  
**Архитектура:** `subagent_output/architecture.md`  
**Техническое задание:** `subagent_output/technical_specification.md`  
**Статус архитектуры:** ✅ Одобрена

---

## Этап 1: Инициализация проекта

### Задача 1.1: Настройка структуры проекта и базовых конфигураций

**Описание:** Создать структуру папок проекта, настроить TypeScript, package.json, и базовые конфигурационные файлы для разработки VS Code расширения.

**Входные данные:** 
- Архитектура раздел 11 (Структура проекта)
- Архитектура раздел 6.1 (Стек технологий)

**Детали реализации:**
1. Создать структуру папок согласно архитектуре:
   ```
   src/
     extension.ts
     types/
     services/
     providers/
     commands/
     utils/
     migrations/
   ```
2. Создать `package.json` с манифестом расширения:
   - Название: `changes-viewer`
   - Версия: `0.1.0`
   - Зависимости: `@types/vscode`, `@types/node`, `typescript`
   - Команды расширения (зарегистрировать заглушки)
   - Активация: `onStartupFinished`
3. Создать `tsconfig.json` с настройками TypeScript:
   - Target: ES2020
   - Module: CommonJS
   - Strict mode включен
4. Создать `.vscode/launch.json` для отладки расширения
5. Создать `.vscodeignore` для исключения файлов из упаковки
6. Создать базовый `README.md` с описанием проекта

**Критерии приемки:**
- ✅ Проект собирается командой `npm run compile`
- ✅ Расширение можно запустить в режиме разработки (F5)
- ✅ Структура папок соответствует архитектуре
- ✅ package.json содержит все необходимые поля для VS Code расширения

**Зависимости:** Нет

---

### Задача 1.2: Создание базовых типов данных

**Описание:** Определить TypeScript интерфейсы и типы для всех сущностей системы (Snapshot, SnapshotSource, DiffInfo и т.д.).

**Входные данные:**
- Архитектура раздел 4.1 (Концептуальная модель данных)
- ТЗ раздел 1.4.2 (Структура данных снапшота)

**Детали реализации:**
1. Создать файл `src/types/snapshot.ts` с интерфейсами:
   - `Snapshot` - основная сущность снапшота
   - `SnapshotSource` - тип для источника создания ('typing' | 'save' | 'filesystem' | 'manual')
   - `SnapshotMetadata` - метаданные снапшота
   - `DiffInfo` - информация об изменении
   - `SnapshotFilters` - фильтры для поиска снапшотов
   - `SnapshotIndex` - индекс для быстрого поиска
   - `StorageMetadata` - метаданные хранилища
2. Экспортировать все типы для использования в других модулях

**Критерии приемки:**
- ✅ Все типы определены согласно архитектуре
- ✅ TypeScript компилируется без ошибок
- ✅ Типы покрывают все поля из модели данных

**Зависимости:** 1.1

---

### Задача 1.3: Создание точки входа расширения (extension.ts)

**Описание:** Реализовать функцию `activate()` для инициализации расширения и регистрации всех компонентов.

**Входные данные:**
- Архитектура раздел 3.2 (Extension Entry Point)
- Архитектура раздел 5.2 (Внутренние интерфейсы)

**Детали реализации:**
1. Создать файл `src/extension.ts` с функцией `activate()`
2. Реализовать базовую структуру активации:
   - Получение `context.globalStoragePath` и `context.globalState`
   - Инициализация сервисов (пока заглушки)
   - Регистрация Timeline Provider (заглушка)
   - Регистрация команд (заглушки)
3. Реализовать функцию `deactivate()` для очистки ресурсов
4. Экспортировать функции для VS Code

**Критерии приемки:**
- ✅ Расширение активируется при запуске VS Code
- ✅ Функция `activate()` вызывается корректно
- ✅ Все компоненты зарегистрированы (пока как заглушки)
- ✅ Нет ошибок при активации

**Зависимости:** 1.1, 1.2

---

## Этап 2: Реализация ядра (Storage Service, Local History Manager)

### Задача 2.1: Реализация Configuration Service

**Описание:** Создать сервис для чтения и валидации настроек расширения из VS Code Settings.

**Входные данные:**
- Архитектура раздел 3.2 (Configuration Service)
- Архитектура раздел 5.2 (Интерфейс ConfigurationService)
- ТЗ раздел 1.4.3 (Политика хранения)

**Детали реализации:**
1. Создать файл `src/services/ConfigurationService.ts`
2. Реализовать класс `ConfigurationService` с методами:
   - `getTypingDebounce()` - возвращает debounce для typing (по умолчанию 2000 мс)
   - `getFileSystemDebounce()` - возвращает debounce для FileSystemWatcher (по умолчанию 1000 мс)
   - `getMaxSnapshotsPerFile()` - максимальное количество снапшотов на файл (по умолчанию 100)
   - `getMaxStorageSize()` - максимальный размер хранилища (по умолчанию 500 MB)
   - `getTTLDays()` - TTL в днях (по умолчанию 90)
   - `getMaxFileSize()` - максимальный размер файла для создания снапшота (по умолчанию 50 MB)
   - `onDidChangeConfiguration()` - подписка на изменения настроек
3. Использовать `vscode.workspace.getConfiguration('changes-viewer')` для чтения настроек
4. Добавить значения по умолчанию для всех настроек

**Критерии приемки:**
- ✅ Все настройки читаются из VS Code Settings
- ✅ Значения по умолчанию применяются, если настройки не заданы
- ✅ Изменения настроек отслеживаются через событие
- ✅ Настройки валидируются (положительные числа, разумные диапазоны)

**Зависимости:** 1.2, 1.3

---

### Задача 2.2: Реализация утилит (Hash, Diff, Time, URI, Retry)

**Описание:** Создать вспомогательные утилиты для вычисления хешей, diff, форматирования времени, валидации URI и повторных попыток.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Утилиты)
- Архитектура раздел 3.2 (Компонент: Utilities)

**Детали реализации:**
1. Создать `src/utils/hash.ts`:
   - Функция `computeHash(content: string | Buffer): Promise<string>` - вычисление SHA-256 хеша
   - Использовать Node.js `crypto.createHash('sha256')`
2. Создать `src/utils/diff.ts`:
   - Функция `computeDiff(content1: string, content2: string): DiffInfo`
   - Реализовать простой алгоритм diff (подсчет добавленных/удаленных/измененных строк)
   - Использовать построчное сравнение
3. Создать `src/utils/time.ts`:
   - Функция `formatRelativeTime(timestamp: number): string` - форматирование относительного времени ("2 minutes ago")
4. Создать `src/utils/uri.ts`:
   - Функция `validateUri(uri: vscode.Uri): boolean` - проверка валидности URI
   - Функция `isInWorkspace(uri: vscode.Uri): boolean` - проверка принадлежности к рабочей области
5. Создать `src/utils/retry.ts`:
   - Функция `retryWithBackoff<T>(fn: () => Promise<T>, maxRetries: number, delay: number): Promise<T>`
   - Реализовать экспоненциальную задержку между попытками

**Критерии приемки:**
- ✅ Hash функция корректно вычисляет SHA-256 хеш
- ✅ Diff функция корректно определяет различия между версиями
- ✅ Time функция форматирует время в читаемый формат
- ✅ URI функции валидируют пути и проверяют принадлежность к рабочей области
- ✅ Retry функция выполняет повторные попытки с экспоненциальной задержкой

**Зависимости:** 1.2

---

### Задача 2.3: Реализация Storage Service

**Описание:** Создать сервис для работы с хранилищем данных (Memento API для метаданных, файловая система для содержимого).

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Управление хранилищем)
- Архитектура раздел 3.2 (Компонент: Storage Service)
- Архитектура раздел 5.2 (Интерфейс StorageService)
- Архитектура раздел 4.2 (Логическая модель данных)

**Детали реализации:**
1. Создать файл `src/services/StorageService.ts`
2. Реализовать класс `StorageService` с методами:
   - `saveSnapshotMetadata(snapshot: Snapshot): Promise<void>` - сохранение метаданных в Memento API
   - `getSnapshotMetadata(snapshotId: string): Promise<Snapshot | null>` - чтение метаданных по ID
   - `getSnapshotsForFile(fileUri: string): Promise<Snapshot[]>` - получение всех снапшотов для файла
   - `saveSnapshotContent(snapshotId: string, content: string, fileHash: string): Promise<string>` - сохранение содержимого в файловую систему
   - `getSnapshotContent(contentPath: string): Promise<string>` - чтение содержимого снапшота
   - `deleteSnapshotContent(contentPath: string): Promise<void>` - удаление содержимого
   - `getStorageSize(): Promise<number>` - вычисление размера хранилища
   - `getStoragePath(): string` - получение пути к хранилищу
3. Реализовать работу с индексом:
   - Структура данных: `{ version, metadata, snapshots[], index: { [fileUri]: snapshotIds[] } }`
   - Обновление индекса при создании/удалении снапшотов
4. Реализовать работу с файловой системой:
   - Создание директорий `snapshots/{fileHash}/`
   - Сохранение содержимого в файлы `{snapshotId}.txt`
   - Защита от path traversal (валидация путей)
5. Использовать `context.globalState` для Memento API
6. Использовать `context.globalStoragePath` для получения пути к хранилищу

**Критерии приемки:**
- ✅ Метаданные сохраняются и читаются из Memento API
- ✅ Содержимое снапшотов сохраняется в файловую систему
- ✅ Индекс корректно обновляется при создании/удалении снапшотов
- ✅ Поиск снапшотов по fileUri работает через индекс
- ✅ Валидация путей защищает от path traversal
- ✅ Ошибки чтения/записи обрабатываются корректно

**Зависимости:** 1.2, 1.3, 2.1, 2.2

---

### Задача 2.4: Реализация Cleanup Service

**Описание:** Создать сервис для управления лимитами хранилища и автоматической очистки старых снапшотов.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Очистка хранилища)
- Архитектура раздел 3.2 (Компонент: Cleanup Service)
- Архитектура раздел 5.2 (Интерфейс CleanupService)
- ТЗ раздел 1.4.3 (Политика хранения)

**Детали реализации:**
1. Создать файл `src/services/CleanupService.ts`
2. Реализовать класс `CleanupService` с методами:
   - `checkLimits(): Promise<LimitStatus>` - проверка превышения лимитов
   - `cleanupByCount(fileUri: vscode.Uri, maxCount: number): Promise<number>` - очистка по лимиту количества на файл
   - `cleanupBySize(maxSize: number): Promise<number>` - очистка по лимиту размера (LRU стратегия)
   - `cleanupByTTL(ttlDays: number): Promise<number>` - очистка по TTL
   - `startPeriodicCleanup(intervalHours: number): void` - запуск периодической очистки
   - `stopPeriodicCleanup(): void` - остановка периодической очистки
3. Реализовать LRU стратегию:
   - Отслеживание времени последнего доступа к снапшотам
   - Сортировка по времени доступа при очистке
4. Реализовать периодическую очистку через `setInterval`
5. Интегрировать с StorageService для удаления снапшотов

**Критерии приемки:**
- ✅ Проверка лимитов работает корректно
- ✅ Очистка по количеству удаляет самые старые снапшоты для файла
- ✅ Очистка по размеру использует LRU стратегию
- ✅ Очистка по TTL удаляет снапшоты старше указанного срока
- ✅ Периодическая очистка запускается и работает в фоне
- ✅ Принятые снапшоты (accepted: true) не удаляются при очистке по TTL

**Зависимости:** 1.2, 2.1, 2.3

---

### Задача 2.5: Реализация Local History Manager

**Описание:** Создать центральный менеджер для управления жизненным циклом снапшотов (CRUD операции).

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Управление снапшотами)
- Архитектура раздел 3.2 (Компонент: Local History Manager)
- Архитектура раздел 5.2 (Интерфейс LocalHistoryManager)

**Детали реализации:**
1. Создать файл `src/services/LocalHistoryManager.ts`
2. Реализовать класс `LocalHistoryManager` с методами:
   - `createSnapshot(fileUri: vscode.Uri, content: string, source: SnapshotSource): Promise<Snapshot>`
   - `getSnapshot(snapshotId: string): Promise<Snapshot | null>`
   - `getSnapshotsForFile(fileUri: vscode.Uri, filters?: SnapshotFilters): Promise<Snapshot[]>`
   - `updateSnapshot(snapshotId: string, updates: Partial<Snapshot>): Promise<Snapshot>`
   - `deleteSnapshot(snapshotId: string): Promise<void>`
   - `deleteSnapshots(snapshotIds: string[]): Promise<void>`
3. Реализовать дедупликацию:
   - Метод `checkDeduplication(fileUri: vscode.Uri, contentHash: string): Promise<boolean>`
   - Проверка хеша последнего снапшота перед созданием нового
4. Реализовать вычисление diff:
   - Метод `computeDiff(snapshot1: Snapshot, snapshot2: Snapshot): Promise<DiffInfo>`
   - Использовать утилиту diff для вычисления различий
5. Интегрировать с StorageService, CleanupService, Hash утилитой
6. Вызывать CleanupService после создания снапшота для проверки лимитов

**Критерии приемки:**
- ✅ Создание снапшота работает с сохранением метаданных и содержимого
- ✅ Дедупликация предотвращает создание дубликатов (по contentHash)
- ✅ Diff вычисляется корректно между снапшотами
- ✅ Обновление и удаление снапшотов работает
- ✅ Фильтрация снапшотов (accepted, source, date range) работает
- ✅ После создания снапшота проверяются лимиты и выполняется очистка при необходимости

**Зависимости:** 1.2, 2.1, 2.2, 2.3, 2.4

---

### Задача 2.6: Реализация миграций данных

**Описание:** Создать систему миграций для версионирования формата данных и обновления структуры хранилища.

**Входные данные:**
- Архитектура раздел 4.4 (Миграции и версионирование)

**Детали реализации:**
1. Создать структуру папок `src/migrations/`
2. Создать файл `src/migrations/index.ts`:
   - Функция `migrateToVersion(targetVersion: string): Promise<void>`
   - Регистрация миграций по версиям
3. Создать файл `src/migrations/v1.0.ts`:
   - Функция `migrateToV1_0(): Promise<void>` - инициализация формата 1.0
   - Создание структуры данных с версией "1.0" если файл не существует
4. Интегрировать миграции в StorageService:
   - Проверка версии при инициализации
   - Запуск миграций при необходимости

**Критерии приемки:**
- ✅ При первом запуске создается структура данных версии 1.0
- ✅ Проверка версии выполняется при активации расширения
- ✅ Миграции можно расширять для будущих версий
- ✅ Миграции идемпотентны (можно запускать несколько раз)

**Зависимости:** 1.2, 2.3

---

## Этап 3: Реализация Change Tracker (Typing, FS Watcher)

### Задача 3.1: Реализация DocumentWatcher (отслеживание изменений в редакторе)

**Описание:** Создать компонент для отслеживания изменений файлов в редакторе VS Code через события `onDidChangeTextDocument`.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Отслеживание изменений, Функция 1)
- Архитектура раздел 3.2 (Компонент: Change Tracker)
- ТЗ UC-01 (Автоматическое создание снапшотов при вводе текста)

**Детали реализации:**
1. Создать файл `src/services/DocumentWatcher.ts`
2. Реализовать класс `DocumentWatcher` с методами:
   - `startWatching(): void` - запуск отслеживания
   - `stopWatching(): void` - остановка отслеживания
   - `handleDocumentChange(event: vscode.TextDocumentChangeEvent): void` - обработка изменений
3. Реализовать debounce механизм:
   - Использовать `setTimeout` для задержки создания снапшота
   - Сбрасывать таймер при новых изменениях
   - Получать debounce значение из ConfigurationService
4. Реализовать логику создания снапшота:
   - Получение содержимого файла из редактора (включая dirty state)
   - Проверка размера файла (пропуск если > maxFileSize)
   - Вызов LocalHistoryManager для создания снапшота с source='typing'
5. Зарегистрировать обработчик `vscode.workspace.onDidChangeTextDocument()`

**Критерии приемки:**
- ✅ Изменения в редакторе отслеживаются через onDidChangeTextDocument
- ✅ Debounce работает корректно (2 секунды по умолчанию)
- ✅ Снапшоты создаются для несохраненных файлов (dirty state)
- ✅ Файлы больше maxFileSize пропускаются
- ✅ Процесс создания снапшота не блокирует ввод текста

**Зависимости:** 1.2, 1.3, 2.1, 2.5

---

### Задача 3.2: Реализация обработчика сохранения файлов

**Описание:** Добавить обработчик события `onDidSaveTextDocument` для создания снапшотов при сохранении файлов.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Отслеживание изменений, Функция 2)
- ТЗ UC-02 (Автоматическое создание снапшота при сохранении файла)

**Детали реализации:**
1. Расширить `DocumentWatcher.ts` или создать отдельный метод
2. Реализовать обработчик `handleDocumentSave(document: vscode.TextDocument): void`
3. Реализовать логику:
   - Чтение сохраненного файла с диска
   - Проверка размера файла
   - Вызов LocalHistoryManager для создания снапшота с source='save'
4. Зарегистрировать обработчик `vscode.workspace.onDidSaveTextDocument()`

**Критерии приемки:**
- ✅ Снапшоты создаются при ручном сохранении (Ctrl+S / Cmd+S)
- ✅ Снапшоты создаются при автосохранении
- ✅ Дедупликация работает (не создается дубликат если содержимое не изменилось)
- ✅ Процесс не замедляет сохранение файла

**Зависимости:** 1.2, 1.3, 2.1, 2.5, 3.1

---

### Задача 3.3: Реализация FileSystemWatcher (отслеживание внешних изменений)

**Описание:** Создать компонент для отслеживания изменений файлов от внешних процессов через FileSystemWatcher.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Отслеживание изменений, Функции 3-5)
- Архитектура раздел 3.2 (Компонент: Change Tracker)
- ТЗ UC-03 (Автоматическое отслеживание изменений от внешних процессов)

**Детали реализации:**
1. Создать файл `src/services/FileSystemWatcher.ts`
2. Реализовать класс `FileSystemWatcher` с методами:
   - `startWatching(): void` - запуск отслеживания
   - `stopWatching(): void` - остановка отслеживания
   - `handleFileChange(uri: vscode.Uri): void` - обработка изменений
   - `handleFileCreate(uri: vscode.Uri): void` - обработка создания файлов
   - `handleFileDelete(uri: vscode.Uri): void` - обработка удаления файлов
   - `isTemporaryFile(uri: vscode.Uri): boolean` - проверка временных файлов
   - `hasDirtyState(uri: vscode.Uri): boolean` - проверка dirty state
3. Реализовать фильтрацию временных файлов:
   - Паттерны: `**/*.tmp`, `**/*.temp`, `**/.~*`, `**/*~`, `**/.*.swp`
   - Игнорирование системных папок: `.git`, `node_modules`, `.vscode`
4. Реализовать debounce для группировки быстрых изменений (1 секунда)
5. Реализовать проверку dirty state:
   - Если файл открыт с несохраненными изменениями, не создавать снапшот
6. Реализовать обработку ошибок чтения файлов:
   - Повторные попытки через retry утилиту (максимум 3 попытки)
7. Создать FileSystemWatcher через `vscode.workspace.createFileSystemWatcher()`
8. Обработать события: `onDidChange`, `onDidCreate`, `onDidDelete`

**Критерии приемки:**
- ✅ FileSystemWatcher отслеживает изменения файлов в рабочей области
- ✅ Временные файлы игнорируются
- ✅ Файлы с dirty state не перезаписывают несохраненные изменения
- ✅ Debounce группирует быстрые множественные изменения
- ✅ Ошибки чтения обрабатываются с повторными попытками
- ✅ Создание и удаление файлов обрабатываются корректно
- ✅ Процесс не блокирует работу VS Code

**Зависимости:** 1.2, 1.3, 2.1, 2.2, 2.5, 3.1

---

### Задача 3.4: Интеграция Change Tracker в extension.ts

**Описание:** Объединить DocumentWatcher и FileSystemWatcher в единый ChangeTracker и интегрировать в точку входа расширения.

**Входные данные:**
- Архитектура раздел 3.2 (Компонент: Change Tracker)

**Детали реализации:**
1. Создать файл `src/services/ChangeTracker.ts` как фасад:
   - Объединить DocumentWatcher и FileSystemWatcher
   - Методы `startTracking()` и `stopTracking()`
2. Обновить `src/extension.ts`:
   - Инициализировать ChangeTracker
   - Запустить отслеживание при активации
   - Остановить отслеживание при деактивации

**Критерии приемки:**
- ✅ ChangeTracker инициализируется при активации расширения
- ✅ Отслеживание изменений запускается автоматически
- ✅ Все компоненты корректно работают вместе

**Зависимости:** 1.3, 3.1, 3.2, 3.3

---

## Этап 4: Реализация Timeline Provider

### Задача 4.1: Реализация LocalHistoryTimelineProvider

**Описание:** Создать провайдер для интеграции с VS Code Timeline API для отображения истории изменений в Timeline view.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Timeline Provider)
- Архитектура раздел 3.2 (Компонент: Timeline Provider)
- Архитектура раздел 5.1 (API: VS Code Timeline API)
- ТЗ UC-04 (Просмотр истории изменений файла)

**Детали реализации:**
1. Создать файл `src/providers/LocalHistoryTimelineProvider.ts`
2. Реализовать класс `LocalHistoryTimelineProvider` реализующий `vscode.TimelineProvider`:
   - `provideTimeline(uri: vscode.Uri, options: vscode.TimelineOptions, token: vscode.CancellationToken): Promise<vscode.TimelineItem[]>`
   - `onDidChange?: vscode.Event<vscode.TimelineChangeEvent>` - событие для обновления Timeline
3. Реализовать метод `provideTimeline()`:
   - Получение снапшотов для файла через LocalHistoryManager
   - Фильтрация принятых снапшотов (accepted: false)
   - Сортировка по timestamp (новые сверху)
   - Пагинация (первые 50 снапшотов, остальные по требованию)
   - Преобразование снапшотов в TimelineItem
4. Реализовать метод `formatSnapshotToTimelineItem(snapshot: Snapshot): vscode.TimelineItem`:
   - Форматирование label ("Typing - 2 minutes ago")
   - Установка иконки в зависимости от source
   - Форматирование description (diff summary)
   - Установка command для открытия снапшота
5. Реализовать событие `onDidChange` для уведомления VS Code об обновлениях
6. Зарегистрировать провайдер в `extension.ts` через `vscode.workspace.registerTimelineProvider()`

**Критерии приемки:**
- ✅ Timeline Provider зарегистрирован и работает
- ✅ История изменений отображается в Timeline view для файлов
- ✅ Снапшоты отсортированы по дате (новые сверху)
- ✅ Принятые снапшоты скрыты из списка
- ✅ Пагинация работает для файлов с большим количеством снапшотов
- ✅ Timeline обновляется при создании новых снапшотов
- ✅ Обработка ошибок работает корректно (пустой список при ошибках)

**Зависимости:** 1.2, 1.3, 2.2, 2.5

---

## Этап 5: Реализация команд (UI)

### Задача 5.1: Реализация команды Restore (восстановление файла)

**Описание:** Создать команду для восстановления файла к версии из снапшота.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Команды и UI, Функция 1)
- Архитектура раздел 3.2 (Компонент: Commands)
- Архитектура раздел 5.1 (API: VS Code Commands, команда restore)
- ТЗ UC-05 (Восстановление файла к версии из снапшота)

**Детали реализации:**
1. Создать файл `src/commands/restoreCommand.ts`
2. Реализовать функцию `restoreCommand(snapshotId: string): Promise<void>`
3. Реализовать логику восстановления:
   - Получение снапшота через LocalHistoryManager
   - Проверка dirty state файла (предупреждение если есть несохраненные изменения)
   - Диалог подтверждения через `vscode.window.showWarningMessage()`
   - Создание снапшота текущей версии (source='manual') перед восстановлением
   - Создание резервной копии текущей версии (если файл существует)
   - Чтение содержимого снапшота из StorageService
   - Запись содержимого в файл на диск
   - Обновление открытого редактора (закрытие и открытие файла)
   - Уведомление пользователя об успешном восстановлении
4. Обработать ошибки:
   - Снапшот недоступен
   - Ошибка записи файла
   - Файл был удален (создание нового файла)
5. Зарегистрировать команду в `package.json` и `extension.ts`

**Критерии приемки:**
- ✅ Команда доступна в контекстном меню Timeline
- ✅ Диалог подтверждения отображается перед восстановлением
- ✅ Несохраненные изменения обрабатываются корректно (сохранение или отбрасывание)
- ✅ Резервная копия создается перед восстановлением
- ✅ Файл корректно восстанавливается к выбранной версии
- ✅ Открытый редактор обновляется после восстановления
- ✅ Ошибки обрабатываются с понятными сообщениями
- ✅ Восстановление работает для удаленных файлов (создание нового файла)

**Зависимости:** 1.2, 1.3, 2.3, 2.5

---

### Задача 5.2: Реализация команды Accept (принятие изменения)

**Описание:** Создать команду для принятия изменения (скрытие снапшота из Timeline).

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Команды и UI, Функция 2)
- Архитектура раздел 5.1 (API: VS Code Commands, команда accept)
- ТЗ UC-06 (Скрытие элемента истории)

**Детали реализации:**
1. Создать файл `src/commands/acceptCommand.ts`
2. Реализовать функцию `acceptCommand(snapshotId: string | string[]): Promise<void>`
3. Реализовать логику принятия:
   - Поддержка одиночного и множественного принятия
   - Обновление метаданных снапшота (accepted: true, acceptedTimestamp: Date.now())
   - Сохранение через LocalHistoryManager
   - Уведомление Timeline Provider об изменении
4. Реализовать возможность "Unaccept" (отменить принятие):
   - Проверка текущего статуса снапшота
   - Если уже принят, отменить принятие (accepted: false)
5. Обработать ошибки сохранения
6. Зарегистрировать команду в `package.json` и `extension.ts`

**Критерии приемки:**
- ✅ Команда доступна в контекстном меню Timeline
- ✅ Принятые снапшоты скрываются из списка истории
- ✅ Принятые снапшоты остаются в хранилище (не удаляются)
- ✅ Возможность отменить принятие ("Unaccept")
- ✅ Массовое принятие работает для нескольких выбранных снапшотов
- ✅ Ошибки сохранения обрабатываются корректно

**Зависимости:** 1.2, 1.3, 2.5, 4.1

---

### Задача 5.3: Реализация команды Diff (сравнение версий)

**Описание:** Создать команду для сравнения версии снапшота с текущей версией файла в Diff-редакторе VS Code.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Команды и UI, Функция 3)
- Архитектура раздел 5.1 (API: VS Code Commands, команда diff)
- ТЗ UC-07 (Сравнение версии файла с текущей версией)

**Детали реализации:**
1. Создать файл `src/commands/diffCommand.ts`
2. Реализовать функцию `diffCommand(snapshotId: string): Promise<void>`
3. Реализовать логику сравнения:
   - Получение снапшота через LocalHistoryManager
   - Чтение содержимого снапшота из StorageService
   - Получение текущего содержимого файла:
     - Если файл открыт в редакторе, получить из редактора (включая dirty state)
     - Если файл не открыт, прочитать с диска
   - Проверка идентичности версий (по хешу или содержимому)
   - Открытие Diff-редактора через `vscode.commands.executeCommand('vscode.diff')`
   - Настройка меток: "Snapshot from <timestamp>" и "Current"
4. Обработать специальные случаи:
   - Версии идентичны (уведомление, не открывать diff)
   - Содержимое снапшота недоступно
   - Файл был удален (diff с пустым файлом)
   - Снапшот-маркер удаления (diff с удаленным файлом)
5. Зарегистрировать команду в `package.json` и `extension.ts`

**Критерии приемки:**
- ✅ Команда доступна в контекстном меню Timeline
- ✅ Diff-редактор корректно отображает различия между версиями
- ✅ Изменения визуально выделены стандартными цветами VS Code
- ✅ Обрабатываются случаи идентичных версий
- ✅ Корректно обрабатывается случай удаленного файла
- ✅ Несохраненные изменения в редакторе учитываются при сравнении

**Зависимости:** 1.2, 1.3, 2.3, 2.5

---

### Задача 5.4: Реализация команды Show Details (детальная информация)

**Описание:** Создать команду для отображения детальной информации о снапшоте.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Команды и UI, Функция 4)
- Архитектура раздел 5.1 (API: VS Code Commands, команда showDetails)
- ТЗ UC-08 (Просмотр детальной информации о снапшоте)

**Детали реализации:**
1. Создать файл `src/commands/showDetailsCommand.ts`
2. Реализовать функцию `showDetailsCommand(snapshotId: string): Promise<void>`
3. Реализовать отображение информации:
   - Получение метаданных снапшота через LocalHistoryManager
   - Форматирование информации:
     - Основная информация: дата, время, источник, размер, количество строк
     - Информация об изменении: добавленные/удаленные/измененные строки
     - Техническая информация: ID, content hash, путь к файлу, статус принятия
   - Отображение через `vscode.window.showInformationMessage()` или создание WebView панели
4. Обработать ошибки загрузки метаданных
5. Зарегистрировать команду в `package.json` и `extension.ts`

**Критерии приемки:**
- ✅ Команда доступна в контекстном меню Timeline
- ✅ Детальная информация содержит все основные метаданные
- ✅ Информация об изменениях отображается, если доступна
- ✅ Техническая информация доступна для отладки
- ✅ Ошибки загрузки метаданных обрабатываются корректно

**Зависимости:** 1.2, 1.3, 2.2, 2.5

---

### Задача 5.5: Реализация команды Clear Snapshots (ручная очистка)

**Описание:** Создать команду для ручной очистки старых снапшотов.

**Входные данные:**
- Архитектура раздел 2.1 (Компонент: Команды и UI, Функция 5)
- Архитектура раздел 5.1 (API: VS Code Commands, команда clearSnapshots)

**Детали реализации:**
1. Создать файл `src/commands/clearSnapshotsCommand.ts`
2. Реализовать функцию `clearSnapshotsCommand(): Promise<void>`
3. Реализовать логику очистки:
   - Диалог выбора параметров очистки (опционально):
     - Возраст снапшотов (старше X дней)
     - Размер хранилища (очистить до X MB)
     - Принятые снапшоты (включить/исключить)
   - Вызов CleanupService с параметрами
   - Отображение результата (количество удаленных снапшотов)
4. Использовать настройки из ConfigurationService для значений по умолчанию
5. Зарегистрировать команду в `package.json` и `extension.ts`

**Критерии приемки:**
- ✅ Команда доступна в Command Palette
- ✅ Очистка работает с настройками по умолчанию
- ✅ Результат очистки отображается пользователю
- ✅ Ошибки обрабатываются корректно

**Зависимости:** 1.2, 1.3, 2.1, 2.4

---

### Задача 5.6: Регистрация команд в package.json и extension.ts

**Описание:** Зарегистрировать все команды в манифесте расширения и точке входа.

**Входные данные:**
- Архитектура раздел 3.2 (Компонент: Commands)
- Архитектура раздел 5.1 (API: VS Code Commands)

**Детали реализации:**
1. Обновить `package.json`:
   - Добавить все команды в секцию `contributes.commands`:
     - `changes-viewer.restore`
     - `changes-viewer.accept`
     - `changes-viewer.diff`
     - `changes-viewer.showDetails`
     - `changes-viewer.clearSnapshots`
   - Добавить команды в контекстное меню Timeline через `contributes.menus`
2. Обновить `src/extension.ts`:
   - Импортировать все команды
   - Зарегистрировать через `vscode.commands.registerCommand()`
   - Сохранить Disposable для очистки при деактивации

**Критерии приемки:**
- ✅ Все команды зарегистрированы в package.json
- ✅ Команды доступны в Command Palette
- ✅ Команды доступны в контекстном меню Timeline
- ✅ Команды корректно вызываются при использовании

**Зависимости:** 1.3, 5.1, 5.2, 5.3, 5.4, 5.5

---

## Этап 6: Финализация

### Задача 6.1: Добавление настроек расширения в package.json

**Описание:** Определить все настройки расширения в секции `contributes.configuration` манифеста.

**Входные данные:**
- Архитектура раздел 10.3 (Конфигурация)
- ТЗ раздел 1.4.3 (Политика хранения)

**Детали реализации:**
1. Обновить `package.json`:
   - Добавить секцию `contributes.configuration` с настройками:
     - `changes-viewer.typingDebounce` (number, default: 2000)
     - `changes-viewer.fileSystemDebounce` (number, default: 1000)
     - `changes-viewer.maxSnapshotsPerFile` (number, default: 100)
     - `changes-viewer.maxStorageSize` (number, default: 524288000)
     - `changes-viewer.ttlDays` (number, default: 90)
     - `changes-viewer.maxFileSize` (number, default: 52428800)
     - `changes-viewer.enableCompression` (boolean, default: true)
     - `changes-viewer.compressionThreshold` (number, default: 10485760)
   - Добавить описания для каждой настройки

**Критерии приемки:**
- ✅ Все настройки определены в package.json
- ✅ Настройки имеют описания и значения по умолчанию
- ✅ Настройки отображаются в VS Code Settings UI
- ✅ ConfigurationService корректно читает все настройки

**Зависимости:** 1.1, 2.1

---

### Задача 6.2: Реализация сжатия файлов для больших снапшотов

**Описание:** Добавить поддержку сжатия (gzip) для снапшотов размером больше порогового значения.

**Входные данные:**
- Архитектура раздел 4.2 (Структура файловой системы)
- ТЗ раздел 1.4.3 (Политика хранения)

**Детали реализации:**
1. Обновить `StorageService`:
   - Добавить проверку размера файла перед сохранением
   - Если размер > compressionThreshold, сжимать через Node.js `zlib.gzip()`
   - Сохранять с расширением `.txt.gz` для сжатых файлов
   - Добавить флаг `compressed: true` в метаданные снапшота
2. Обновить чтение содержимого:
   - Проверять флаг `compressed` или расширение файла
   - Если сжато, распаковывать через `zlib.gunzip()`
3. Обновить модель данных Snapshot (добавить `metadata.compressed?: boolean`)

**Критерии приемки:**
- ✅ Файлы > compressionThreshold сжимаются при сохранении
- ✅ Сжатые файлы корректно распаковываются при чтении
- ✅ Флаг compressed сохраняется в метаданных
- ✅ Сжатие экономит место в хранилище

**Зависимости:** 1.2, 2.3

---

### Задача 6.3: Добавление логирования и Output Channel

**Описание:** Реализовать систему логирования для отладки и мониторинга работы расширения.

**Входные данные:**
- Архитектура раздел 9.3 (Мониторинг и алертинг)
- Ревью архитектуры раздел 5.4 (Логирование и отладка)

**Детали реализации:**
1. Создать файл `src/utils/logger.ts`:
   - Класс `Logger` с методами: `debug()`, `info()`, `warn()`, `error()`
   - Использование `vscode.window.createOutputChannel('Changes Viewer')`
   - Уровни логирования (DEBUG, INFO, WARN, ERROR)
2. Интегрировать логирование во все компоненты:
   - Логировать создание/удаление снапшотов
   - Логировать ошибки с деталями
   - Логировать операции очистки
3. Добавить настройку для включения/выключения детального логирования

**Критерии приемки:**
- ✅ Output Channel создается и отображается в VS Code
- ✅ Логи записываются с правильными уровнями
- ✅ Ошибки логируются с деталями
- ✅ Детальное логирование можно включить/выключить через настройки

**Зависимости:** 1.2, 1.3

---

### Задача 6.4: Обработка ошибок и edge cases

**Описание:** Добавить обработку всех edge cases и ошибок, описанных в ТЗ и архитектуре.

**Входные данные:**
- ТЗ раздел 2 (Список юзер-кейсов, альтернативные сценарии)
- Архитектура раздел 9.1 (Обработка ошибок)

**Детали реализации:**
1. Обработать все альтернативные сценарии из ТЗ:
   - UC-01: Файл слишком большой, ошибка записи, дедупликация
   - UC-02: Файл удален до сохранения, идентичное содержимое
   - UC-03: Dirty state, временные файлы, множественные изменения, ошибки чтения
   - UC-04: Нет снапшотов, все приняты, ошибка чтения, большое количество
   - UC-05: Отмена восстановления, dirty state, недоступное содержимое, ошибка записи, удаленный файл
   - UC-06: Уже принят, ошибка сохранения, массовое принятие
   - UC-07: Идентичные версии, недоступное содержимое, удаленный файл
   - UC-08: Недоступные метаданные
2. Добавить обработку ошибок во все компоненты:
   - Try-catch блоки
   - Повторные попытки через retry утилиту
   - Понятные сообщения пользователю
3. Добавить валидацию входных данных во всех точках входа

**Критерии приемки:**
- ✅ Все альтернативные сценарии из ТЗ обработаны
- ✅ Ошибки не прерывают работу редактора
- ✅ Пользователю показываются понятные сообщения об ошибках
- ✅ Критичные ошибки логируются для отладки

**Зависимости:** Все предыдущие задачи

---

### Задача 6.5: Создание README и документации

**Описание:** Создать документацию для пользователей и разработчиков расширения.

**Входные данные:**
- Архитектура раздел 7.2 (Документация)

**Детали реализации:**
1. Обновить `README.md`:
   - Описание расширения и его возможностей
   - Инструкции по установке
   - Инструкции по использованию
   - Описание всех команд
   - Описание настроек
   - Troubleshooting guide
2. Добавить примеры использования:
   - Как просмотреть историю изменений
   - Как восстановить файл
   - Как принять изменение
   - Как сравнить версии

**Критерии приемки:**
- ✅ README содержит полное описание расширения
- ✅ Инструкции по установке и использованию понятны
- ✅ Все команды и настройки описаны
- ✅ Troubleshooting guide помогает решить частые проблемы

**Зависимости:** Все предыдущие задачи

---

### Задача 6.6: Финальная проверка и оптимизация

**Описание:** Выполнить финальную проверку всех компонентов, оптимизацию производительности и исправление найденных проблем.

**Входные данные:**
- Все предыдущие задачи
- ТЗ раздел 3.1 (Производительность)

**Детали реализации:**
1. Проверить соответствие всех компонентов архитектуре
2. Проверить покрытие всех юзер-кейсов из ТЗ
3. Оптимизировать производительность:
   - Проверить время создания снапшотов (должно быть < 100ms для файлов < 1 MB)
   - Проверить время загрузки Timeline (должно быть < 1 секунда для 1000 снапшотов)
   - Оптимизировать операции чтения/записи при необходимости
4. Исправить найденные баги и проблемы
5. Проверить работу на разных платформах (Windows, macOS, Linux)

**Критерии приемки:**
- ✅ Все компоненты соответствуют архитектуре
- ✅ Все юзер-кейсы из ТЗ реализованы и работают
- ✅ Производительность соответствует требованиям ТЗ
- ✅ Нет критичных багов
- ✅ Расширение работает на всех поддерживаемых платформах

**Зависимости:** Все предыдущие задачи

---

## Итоговая структура плана

План разбит на **6 этапов** с **26 задачами**:

1. **Инициализация проекта** (3 задачи) - настройка структуры, типов, точки входа
2. **Реализация ядра** (6 задач) - Storage, Cleanup, Local History Manager, утилиты, миграции
3. **Change Tracker** (4 задачи) - отслеживание изменений в редакторе и файловой системе
4. **Timeline Provider** (1 задача) - интеграция с VS Code Timeline API
5. **Команды UI** (6 задач) - все команды для взаимодействия пользователя
6. **Финализация** (6 задач) - настройки, сжатие, логирование, документация, оптимизация

Все задачи имеют четкие описания, критерии приемки и зависимости. План покрывает 100% функционала из архитектуры и ТЗ.
