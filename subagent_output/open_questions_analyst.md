# Открытые вопросы по техническому заданию

## Вопрос 1: Использование Timeline API для отображения
**Контекст:** VS Code предоставляет Timeline API для отображения истории изменений в стандартном Timeline view. Это позволяет интегрироваться со стандартным интерфейсом VS Code.

**Проблема:** Следует ли использовать Timeline API для отображения Local History или создать собственный Custom View?

**Варианты решения:**
1. **Использовать Timeline API** (рекомендуется для первой версии)
   - Преимущества: быстрая реализация, стандартный интерфейс VS Code, интеграция с другими расширениями
   - Недостатки: ограниченный контроль над UI/UX
2. **Создать собственный Custom View**
   - Преимущества: полный контроль над интерфейсом, возможность добавить дополнительные функции
   - Недостатки: больше работы, нестандартный интерфейс

**Рекомендация:** Использовать Timeline API для первой версии. При необходимости можно добавить Custom View в будущих версиях.

**Блокирует:** Определение архитектуры UI компонентов

---

## Вопрос 2: Стратегия хранения больших файлов
**Контекст:** Некоторые файлы могут быть очень большими (десятки мегабайт). Создание снапшотов для таких файлов может занимать много времени и места.

**Проблема:** Следует ли создавать снапшоты для больших файлов или пропускать их? Если создавать, то как оптимизировать хранение?

**Варианты решения:**
1. **Пропускать файлы больше определенного размера** (например, 10 MB или 50 MB)
   - Преимущества: простота, экономия места
   - Недостатки: нет истории для больших файлов
2. **Создавать снапшоты, но хранить только diff** (различия между версиями)
   - Преимущества: экономия места, история для всех файлов
   - Недостатки: сложность реализации, требуется предыдущий снапшот для восстановления
3. **Создавать снапшоты для всех файлов, но применять сжатие** (gzip)
   - Преимущества: история для всех файлов, экономия места
   - Недостатки: дополнительная нагрузка на CPU

**Рекомендация:** Комбинированный подход:
- Пропускать файлы больше 50 MB (настраиваемо)
- Для файлов 10-50 MB применять сжатие (gzip)
- Для файлов меньше 10 MB хранить без сжатия

**Блокирует:** Определение политики хранения и алгоритма оптимизации

---

## Вопрос 3: Очистка старых снапшотов
**Контекст:** Со временем накапливается большое количество снапшотов. Необходим механизм очистки для предотвращения переполнения хранилища.

**Проблема:** Когда и как очищать старые снапшоты? Какие снапшоты удалять в первую очередь?

**Варианты решения:**
1. **Автоматическая очистка при достижении лимитов** (LRU - Least Recently Used)
   - Преимущества: автоматическая работа, не требует действий пользователя
   - Недостатки: может удалить важные снапшоты
2. **Периодическая очистка по расписанию** (например, раз в день)
   - Преимущества: предсказуемость, можно настроить время
   - Недостатки: может не успевать очищать при активной работе
3. **Ручная очистка через команду пользователя**
   - Преимущества: полный контроль пользователя
   - Недостатки: требует действий пользователя, может забыть очистить

**Рекомендация:** Комбинированный подход:
- Автоматическая очистка при достижении лимитов (LRU)
- Периодическая очистка по расписанию (раз в день, в нерабочее время)
- Команда для ручной очистки ("Clear Old Snapshots")

**Блокирует:** Определение механизма очистки и алгоритма выбора снапшотов для удаления

---

## Вопрос 4: Обработка конфликтов при восстановлении
**Контекст:** При восстановлении файла к версии из снапшота может возникнуть конфликт, если файл был изменен после создания снапшота.

**Проблема:** Как обрабатывать конфликты? Создавать резервную копию? Показывать diff перед восстановлением?

**Варианты решения:**
1. **Всегда создавать резервную копию** перед восстановлением
   - Преимущества: безопасность, можно откатить
   - Недостатки: занимает дополнительное место
2. **Показывать diff перед восстановлением** для файлов с несохраненными изменениями
   - Преимущества: пользователь видит, что будет потеряно
   - Недостатки: дополнительный шаг, может замедлить процесс
3. **Автоматически создавать снапшот текущей версии** перед восстановлением
   - Преимущества: история сохраняется, можно восстановить обратно
   - Недостатки: создает дополнительный снапшот

**Рекомендация:** Комбинированный подход:
- Всегда создавать снапшот текущей версии перед восстановлением (сохраняет историю)
- Показывать предупреждение для файлов с несохраненными изменениями
- Опционально создавать резервную копию в отдельной папке (настраиваемо)

**Блокирует:** Определение UX для процесса восстановления

---

## Вопрос 5: Настройки по умолчанию
**Контекст:** Расширение имеет множество настраиваемых параметров (debounce, лимиты, TTL и т.д.).

**Проблема:** Какие значения по умолчанию установить для настроек? Как сбалансировать производительность и функциональность?

**Варианты решения:**
1. **Консервативные настройки** (меньше снапшотов, больше debounce)
   - Преимущества: меньше нагрузка, меньше место
   - Недостатки: может пропустить некоторые изменения
2. **Агрессивные настройки** (больше снапшотов, меньше debounce)
   - Преимущества: полная история изменений
   - Недостатки: больше нагрузка, больше место
3. **Сбалансированные настройки** (средние значения)
   - Преимущества: баланс между функциональностью и производительностью
   - Недостатки: может не подойти для всех случаев

**Рекомендация:** Сбалансированные настройки по умолчанию:
- Debounce для typing: 2 секунды
- Debounce для FileSystemWatcher: 1 секунда
- Максимум снапшотов на файл: 100
- Максимальный размер хранилища: 500 MB
- TTL: 90 дней
- Максимальный размер файла: 50 MB

Пользователь может изменить все настройки через VS Code Settings.

**Блокирует:** Определение конфигурации расширения

---

## Вопрос 6: Миграция данных при обновлении расширения
**Контекст:** При обновлении расширения может измениться формат хранения данных.

**Проблема:** Как обрабатывать миграцию данных при обновлении? Нужна ли обратная совместимость?

**Варианты решения:**
1. **Автоматическая миграция** при обновлении
   - Преимущества: прозрачно для пользователя
   - Недостатки: сложность реализации, может занять время
2. **Очистка старых данных** при обновлении
   - Преимущества: простота, нет проблем совместимости
   - Недостатки: потеря истории при обновлении
3. **Поддержка нескольких форматов** (обратная совместимость)
   - Преимущества: сохранение истории
   - Недостатки: сложность, больше кода

**Рекомендация:** Автоматическая миграция с версионированием формата данных:
- Каждая версия формата имеет номер версии
- При обновлении проверяется версия формата
- Если версия устарела, выполняется миграция
- Если миграция невозможна, данные очищаются с предупреждением пользователя

**Блокирует:** Определение стратегии версионирования и миграции

---

## Резюме

Все критические вопросы из исходных требований решены. Оставшиеся вопросы касаются деталей реализации и оптимизации, которые можно решить на этапе архитектурного проектирования или разработки.

**Рекомендация:** Переходить к архитектурному проектированию с учетом решений, предложенных в вопросах выше.
