# Техническое задание: VS Code расширение "Changes Viewer"

## 1. Общее описание

### 1.1. Краткое описание задачи
Разработать VS Code расширение `changes_viewer`, которое реализует **Local History Provider** - систему локального хранения и просмотра истории изменений файлов. Расширение автоматически отслеживает изменения файлов (как в редакторе, так и от внешних процессов), создает снапшоты и позволяет пользователям просматривать, сравнивать, восстанавливать и управлять историей изменений.

### 1.2. Цель разработки
Создать независимую от систем контроля версий систему локальной истории изменений, которая:
- Автоматически отслеживает все изменения файлов в реальном времени
- Сохраняет снапшоты локально для быстрого доступа
- Предоставляет удобный интерфейс для работы с историей изменений
- Позволяет восстанавливать предыдущие версии файлов
- Отслеживает изменения от внешних процессов (подагентов, скриптов и т.д.)

### 1.3. Связь с существующей системой
- **Проект:** Новый проект, репозиторий содержит только файл LICENSE
- **Интеграция:** Расширение интегрируется с VS Code через:
  - `onDidChangeTextDocument` - для отслеживания изменений в редакторе
  - `FileSystemWatcher` - для отслеживания изменений от внешних процессов
  - `Timeline API` - для отображения истории в стандартном Timeline view VS Code (опционально)
- **Зависимости:** VS Code Extension API, встроенные механизмы VS Code для работы с файлами

### 1.4. Архитектура хранения данных

#### 1.4.1. Механизм хранения
Расширение использует **VS Code Extension Context Storage** (Memento API) для хранения метаданных и индексов, и **файловую систему** для хранения содержимого снапшотов.

**Вариант 1 (Рекомендуемый):** JSON файлы в `globalStorage`
- Метаданные снапшотов: JSON файл в `globalStorage/{extensionId}/snapshots.json`
- Содержимое файлов: отдельные файлы в `globalStorage/{extensionId}/snapshots/{fileHash}/`
- Преимущества: простота реализации, легко отлаживать, не требует дополнительных зависимостей
- Недостатки: может быть медленнее при большом количестве снапшотов

**Вариант 2 (Альтернативный):** SQLite база данных
- Единая база данных в `globalStorage/{extensionId}/history.db`
- Преимущества: быстрый поиск, эффективное хранение, поддержка сложных запросов
- Недостатки: требует зависимости (sqlite3), сложнее в отладке

**Решение:** Начать с Варианта 1 (JSON), при необходимости мигрировать на SQLite.

#### 1.4.2. Структура данных снапшота
```typescript
interface Snapshot {
  id: string;                    // Уникальный идентификатор снапшота (UUID)
  fileUri: string;               // URI файла (vscode.Uri.toString())
  filePath: string;              // Абсолютный путь к файлу
  timestamp: number;             // Unix timestamp создания снапшота
  source: 'typing' | 'save' | 'filesystem' | 'manual'; // Источник создания
  contentHash: string;           // SHA-256 хеш содержимого (для дедупликации)
  contentPath: string;           // Путь к файлу с содержимым снапшота
  metadata: {
    lineCount: number;          // Количество строк в файле
    size: number;               // Размер файла в байтах
    encoding?: string;           // Кодировка файла
  };
  diffInfo?: {                  // Информация об изменении (опционально)
    previousSnapshotId?: string; // ID предыдущего снапшота
    addedLines: number;         // Количество добавленных строк
    removedLines: number;        // Количество удаленных строк
    modifiedLines: number;       // Количество измененных строк
  };
  accepted: boolean;             // Флаг "принято" (скрыто из списка)
  acceptedTimestamp?: number;    // Время принятия (если принято)
}
```

#### 1.4.3. Политика хранения
- **Максимальное количество снапшотов на файл:** 100 (настраиваемо)
- **Максимальный общий размер хранилища:** 500 MB (настраиваемо)
- **TTL (Time To Live):** 90 дней (настраиваемо)
- **Стратегия очистки:** LRU (Least Recently Used) - при достижении лимитов удаляются самые старые неиспользуемые снапшоты
- **Дедупликация:** Если содержимое файла идентично предыдущему снапшоту (по contentHash), новый снапшот не создается

---

## 2. Список юзер-кейсов

### UC-01: Автоматическое создание снапшотов при вводе текста в редакторе

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Редактор VS Code
- Система (расширение changes_viewer)
- Local Storage

**Предусловия:**
- Расширение `changes_viewer` установлено и активировано
- Файл открыт в редакторе VS Code
- Пользователь начинает вводить текст в файл

**Основной сценарий:**
1. Пользователь открывает файл в редакторе VS Code
2. Расширение регистрирует обработчик события `onDidChangeTextDocument` для файла
3. Пользователь начинает вводить текст в редактор
4. Система получает событие `onDidChangeTextDocument` с информацией об изменении
5. Система запускает debounce-таймер (по умолчанию 2 секунды)
6. Если в течение debounce-периода происходят новые изменения, таймер сбрасывается
7. После окончания debounce-периода без новых изменений:
  8. Система получает текущее содержимое файла из редактора (включая несохраненные изменения - "dirty state")
  9. Система вычисляет SHA-256 хеш содержимого
  10. Система проверяет, отличается ли содержимое от последнего снапшота (по хешу)
  11. Если содержимое отличается:
    12. Система создает новый снапшот с метаданными:
      - `source: 'typing'`
      - `timestamp: Date.now()`
      - `contentHash: <вычисленный хеш>`
      - `fileUri: <URI открытого файла>`
    13. Система сохраняет содержимое файла в Local Storage
    14. Система вычисляет diff между текущим и предыдущим снапшотом (если есть)
    15. Система сохраняет метаданные снапшота в индекс
    16. Система проверяет лимиты хранения и при необходимости удаляет старые снапшоты
17. Снапшот создан и доступен для просмотра в истории

**Альтернативные сценарии:**

**А1: Содержимое идентично предыдущему снапшоту (на шаге 10)**
1. Система обнаруживает, что contentHash совпадает с последним снапшотом
2. Система не создает новый снапшот (дедупликация)
3. Конец юзер-кейса (снапшот не создан)

**А2: Файл слишком большой (на шаге 13)**
1. Система проверяет размер файла
2. Если размер превышает лимит (например, 10 MB), система пропускает создание снапшота
3. Система логирует предупреждение (не показывая пользователю, чтобы не мешать работе)
4. Конец юзер-кейса (снапшот не создан)

**А3: Ошибка записи в Local Storage (на шаге 13)**
1. Система пытается сохранить снапшот в Local Storage
2. Происходит ошибка (недостаточно места, ошибка файловой системы и т.д.)
3. Система пытается освободить место, удаляя старые снапшоты
4. Если освобождение места не помогло, система логирует ошибку
5. Снапшот не создан, но работа редактора не прерывается
6. Конец юзер-кейса

**А4: Пользователь быстро вводит текст (на шаге 5-6)**
1. Пользователь вводит текст очень быстро
2. Debounce-таймер постоянно сбрасывается
3. После паузы в вводе (2 секунды) создается один снапшот для всей серии изменений
4. Возврат к шагу 7 основного сценария

**Постусловия:**
- Создан снапшот с содержимым файла на момент окончания ввода
- Снапшот сохранен в Local Storage
- Метаданные снапшота добавлены в индекс
- Снапшот доступен для просмотра в истории изменений

**Критерии приёмки:**
- ✅ Снапшоты создаются автоматически при вводе текста (с debounce 2 секунды)
- ✅ Снапшоты создаются даже для несохраненных файлов (dirty state)
- ✅ Дедупликация работает корректно (идентичное содержимое не создает дубликаты)
- ✅ Процесс создания снапшота не блокирует ввод текста пользователем
- ✅ Ошибки записи обрабатываются без прерывания работы редактора
- ✅ Соблюдаются лимиты хранения (количество, размер, TTL)

---

### UC-02: Автоматическое создание снапшота при сохранении файла

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Редактор VS Code
- Система (расширение changes_viewer)
- Local Storage

**Предусловия:**
- Расширение `changes_viewer` установлено и активировано
- Файл открыт в редакторе и содержит несохраненные изменения
- Пользователь сохраняет файл (Ctrl+S / Cmd+S)

**Основной сценарий:**
1. Пользователь сохраняет файл (через команду Save или автосохранение)
2. Система получает событие `onDidSaveTextDocument`
3. Система получает содержимое сохраненного файла с диска
4. Система вычисляет SHA-256 хеш содержимого
5. Система проверяет, отличается ли содержимое от последнего снапшота (по хешу)
6. Если содержимое отличается:
  7. Система создает новый снапшот с метаданными:
    - `source: 'save'`
    - `timestamp: Date.now()`
    - `contentHash: <вычисленный хеш>`
    - `fileUri: <URI сохраненного файла>`
  8. Система сохраняет содержимое файла в Local Storage
  9. Система вычисляет diff между текущим и предыдущим снапшотом
  10. Система сохраняет метаданные снапшота в индекс
  11. Система проверяет лимиты хранения и при необходимости удаляет старые снапшоты
12. Снапшот создан и доступен для просмотра в истории

**Альтернативные сценарии:**

**А1: Содержимое идентично предыдущему снапшоту (на шаге 5)**
1. Система обнаруживает, что contentHash совпадает с последним снапшотом
2. Система обновляет метаданные последнего снапшота, меняя `source` на 'save' (если предыдущий был 'typing')
3. Или система не создает новый снапшот (в зависимости от настроек)
4. Конец юзер-кейса

**А2: Файл был удален до сохранения (на шаге 3)**
1. Система пытается прочитать файл с диска
2. Файл не существует (был удален)
3. Система не создает снапшот
4. Конец юзер-кейса

**Постусловия:**
- Создан снапшот с содержимым сохраненного файла
- Снапшот помечен источником 'save'
- Снапшот доступен для просмотра в истории изменений

**Критерии приёмки:**
- ✅ Снапшоты создаются автоматически при сохранении файла
- ✅ Снапшоты создаются как при ручном сохранении, так и при автосохранении
- ✅ Дедупликация работает корректно
- ✅ Процесс создания снапшота не замедляет сохранение файла
- ✅ Обрабатываются случаи удаленных файлов

---

### UC-03: Автоматическое отслеживание изменений от внешних процессов через FileSystemWatcher

**Тип:** Новый Use Case

**Актёры:**
- Внешний процесс (подагент, скрипт, другая программа)
- Файловая система
- Система (расширение changes_viewer)
- FileSystemWatcher
- Local Storage

**Предусловия:**
- Расширение `changes_viewer` установлено и активировано
- Файл существует в рабочей области VS Code
- FileSystemWatcher зарегистрирован для отслеживания изменений файлов

**Основной сценарий:**
1. Расширение при активации создает FileSystemWatcher для рабочей области:
   ```typescript
   const watcher = vscode.workspace.createFileSystemWatcher(
     new vscode.RelativePattern(workspaceFolder, '**/*'),
     false, // ignoreCreateEvents (будем обрабатывать отдельно)
     false, // ignoreChangeEvents (НЕ игнорируем!)
     false  // ignoreDeleteEvents (будем обрабатывать отдельно)
   );
   ```
2. Внешний процесс (подагент, скрипт и т.д.) изменяет файл на диске
3. FileSystemWatcher получает событие `onDidChange` для измененного файла
4. Система проверяет, не открыт ли файл в редакторе VS Code:
   - Если файл открыт и имеет несохраненные изменения (dirty), система НЕ создает снапшот (чтобы избежать конфликтов)
   - Если файл открыт, но сохранен, или файл не открыт - продолжаем
5. Система читает содержимое измененного файла с диска
6. Система вычисляет SHA-256 хеш содержимого
7. Система проверяет, отличается ли содержимое от последнего снапшота (по хешу)
8. Если содержимое отличается:
  9. Система создает новый снапшот с метаданными:
    - `source: 'filesystem'`
    - `timestamp: Date.now()`
    - `contentHash: <вычисленный хеш>`
    - `fileUri: <URI измененного файла>`
  10. Система сохраняет содержимое файла в Local Storage
  11. Система вычисляет diff между текущим и предыдущим снапшотом
  12. Система сохраняет метаданные снапшота в индекс
  13. Система проверяет лимиты хранения и при необходимости удаляет старые снапшоты
  14. Система уведомляет Timeline API об изменении (если используется Timeline view)
15. Снапшот создан и доступен для просмотра в истории

**Альтернативные сценарии:**

**А1: Файл открыт в редакторе с несохраненными изменениями (на шаге 4)**
1. Система обнаруживает, что файл открыт и имеет dirty state
2. Система НЕ создает снапшот из FileSystemWatcher (чтобы не перезаписать несохраненные изменения пользователя)
3. Система логирует событие для отладки
4. Конец юзер-кейса (снапшот не создан)

**А2: Файл был удален внешним процессом (событие onDidDelete)**
1. FileSystemWatcher получает событие `onDidDelete` для файла
2. Система создает специальный снапшот-маркер удаления:
   - `source: 'filesystem'`
   - `contentHash: null` (файл не существует)
   - `metadata.deleted: true`
3. Система сохраняет метаданные в индекс
4. Снапшот-маркер доступен в истории для восстановления файла

**А3: Файл был создан внешним процессом (событие onDidCreate)**
1. FileSystemWatcher получает событие `onDidCreate` для нового файла
2. Система читает содержимое нового файла
3. Система создает снапшот с метаданными:
   - `source: 'filesystem'`
   - `metadata.created: true`
4. Система сохраняет снапшот в Local Storage
5. Возврат к шагу 15 основного сценария

**А4: Множественные быстрые изменения (на шаге 3)**
1. Внешний процесс быстро изменяет файл несколько раз подряд
2. FileSystemWatcher генерирует несколько событий `onDidChange`
3. Система использует debounce (1 секунда) для группировки быстрых изменений
4. После окончания debounce-периода создается один снапшот с финальным содержимым
5. Возврат к шагу 8 основного сценария

**А5: Временные файлы (на шаге 5)**
1. Система проверяет путь файла на соответствие паттернам временных файлов:
   - `**/*.tmp`, `**/*.temp`, `**/.~*`, `**/*~`, `**/.*.swp`
   - Файлы в системных папках (`.git`, `node_modules`, `.vscode` и т.д.)
2. Если файл является временным, система игнорирует событие
3. Снапшот не создается
4. Конец юзер-кейса

**А6: Ошибка чтения файла (на шаге 5)**
1. Система пытается прочитать файл с диска
2. Происходит ошибка (файл заблокирован, нет прав доступа и т.д.)
3. Система логирует ошибку
4. Система повторяет попытку через 500ms (максимум 3 попытки)
5. Если все попытки неудачны, снапшот не создается
6. Конец юзер-кейса

**Постусловия:**
- Создан снапшот с содержимым файла, измененного внешним процессом
- Снапшот помечен источником 'filesystem'
- Снапшот доступен для просмотра в истории изменений
- FileSystemWatcher продолжает отслеживать изменения

**Критерии приёмки:**
- ✅ FileSystemWatcher корректно отслеживает изменения файлов от внешних процессов
- ✅ Снапшоты создаются для изменений, сделанных подагентами и скриптами
- ✅ Изменения файлов, открытых с несохраненными изменениями, не перезаписывают dirty state
- ✅ Временные файлы игнорируются
- ✅ Быстрые множественные изменения группируются через debounce
- ✅ Ошибки чтения файлов обрабатываются с повторными попытками
- ✅ Процесс создания снапшота не блокирует работу VS Code

---

### UC-04: Просмотр истории изменений файла

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Система (расширение changes_viewer)
- Timeline API (опционально)
- Local Storage

**Предусловия:**
- Расширение `changes_viewer` установлено и активировано
- Файл открыт в редакторе VS Code или выбран в Explorer
- Для файла существует хотя бы один снапшот в Local Storage

**Основной сценарий:**
1. Пользователь открывает файл в редакторе или выбирает файл в Explorer
2. Пользователь открывает Timeline view (через Command Palette: "Timeline: Focus on Timeline View" или через контекстное меню файла: "Open Timeline")
3. Система получает запрос на отображение Timeline для файла
4. Система запрашивает все снапшоты для файла из Local Storage (исключая принятые - `accepted: false`)
5. Система сортирует снапшоты по timestamp (новые сверху)
6. Система форматирует снапшоты в формат TimelineItem для Timeline API:
   - `id`: ID снапшота
   - `label`: Описание снапшота (например, "Typing - 2 minutes ago")
   - `timestamp`: Timestamp снапшота
   - `iconPath`: Иконка в зависимости от источника (typing, save, filesystem)
   - `description`: Детали изменения (количество добавленных/удаленных строк)
   - `command`: Команда для открытия снапшота
7. Система передает TimelineItems в Timeline view через Timeline API
8. Timeline view отображает список снапшотов:
   - Дата и время создания
   - Источник создания (иконка и текст: "Typing", "Saved", "External change")
   - Краткое описание изменения (diff summary)
   - Индикатор принятого статуса (если принято - не отображается)
9. Пользователь видит историю изменений файла

**Альтернативные сценарии:**

**А1: Файл не имеет снапшотов (на шаге 4)**
1. Система не находит снапшотов для файла в Local Storage
2. Timeline view отображает сообщение: "No local history available for this file"
3. Конец юзер-кейса

**А2: Все снапшоты приняты (на шаге 4)**
1. Система находит снапшоты, но все имеют `accepted: true`
2. Timeline view отображает сообщение: "No unaccepted changes available" или пустой список
3. Пользователь может использовать команду "Show Accepted" для просмотра принятых снапшотов
4. Конец юзер-кейса

**А3: Ошибка чтения из Local Storage (на шаге 4)**
1. Система пытается прочитать снапшоты из Local Storage
2. Происходит ошибка (файл поврежден, нет прав доступа и т.д.)
3. Система отображает уведомление: "Failed to load local history"
4. Система логирует ошибку для отладки
5. Timeline view остается пустым
6. Конец юзер-кейса

**А4: Большое количество снапшотов (на шаге 5)**
1. Система находит более 1000 снапшотов для файла
2. Система применяет пагинацию: загружает первые 50 снапшотов
3. Остальные снапшоты загружаются по требованию (lazy loading) при прокрутке
4. Возврат к шагу 6 основного сценария

**Постусловия:**
- Timeline view отображает историю изменений для файла
- Пользователь может видеть все непринятые снапшоты
- Снапшоты отсортированы по дате (новые сверху)

**Критерии приёмки:**
- ✅ Timeline view открывается для любого файла в рабочей области
- ✅ История изменений отображается в хронологическом порядке (новые сверху)
- ✅ Каждый элемент Timeline содержит дату, источник и описание изменения
- ✅ Принятые снапшоты скрыты из списка по умолчанию
- ✅ Обработка ошибок работает корректно
- ✅ Пагинация работает для файлов с большим количеством снапшотов

---

### UC-05: Восстановление файла к версии из снапшота (Restore)

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Система (расширение changes_viewer)
- Редактор VS Code
- Local Storage
- Файловая система

**Предусловия:**
- UC-04 выполнен успешно (Timeline view отображает историю изменений)
- В Timeline view есть хотя бы один элемент с историей изменений
- Пользователь выбрал элемент снапшота из Timeline

**Основной сценарий:**
1. Пользователь просматривает Timeline view с историей изменений (результат UC-04)
2. Пользователь выбирает снапшот из списка
3. Пользователь использует команду "Restore" из контекстного меню или нажимает кнопку "Restore"
4. Система отображает диалог подтверждения:
   - "Restore file to this version?"
   - "This will replace the current file content. Current unsaved changes will be lost."
   - Кнопки: "Restore", "Cancel"
5. Пользователь подтверждает действие, нажимая "Restore"
6. Система проверяет, есть ли несохраненные изменения в открытом файле:
   - Если файл открыт и имеет dirty state, система предупреждает пользователя
   - Пользователь может сохранить изменения перед восстановлением или отменить
7. Система получает содержимое снапшота из Local Storage по `contentPath`
8. Система проверяет, существует ли файл на диске:
   - Если файл существует, система создает резервную копию текущей версии
   - Если файл не существует, система создает новый файл
9. Система записывает содержимое снапшота в файл на диск
10. Система обновляет открытый редактор (если файл открыт):
    - Закрывает текущую вкладку с несохраненными изменениями
    - Открывает восстановленный файл
11. Система создает новый снапшот для восстановленной версии (чтобы сохранить историю восстановления):
    - `source: 'manual'`
    - `timestamp: Date.now()`
    - `metadata.restoredFrom: <ID исходного снапшота>`
12. Система отображает уведомление: "File restored to version from <timestamp>"
13. Файл восстановлен к выбранной версии

**Альтернативные сценарии:**

**А1: Пользователь отменяет восстановление (на шаге 5)**
1. Пользователь нажимает "Cancel" в диалоге подтверждения
2. Действие прерывается
3. Файл остается без изменений
4. Конец юзер-кейса

**А2: Файл открыт с несохраненными изменениями (на шаге 6)**
1. Система обнаруживает, что файл открыт и имеет dirty state
2. Система отображает дополнительное предупреждение:
   - "File has unsaved changes. Save them before restoring?"
   - Кнопки: "Save & Restore", "Discard & Restore", "Cancel"
3. Если пользователь выбирает "Save & Restore":
   - Система сохраняет текущие изменения
   - Система создает снапшот для сохраненной версии
   - Возврат к шагу 7 основного сценария
4. Если пользователь выбирает "Discard & Restore":
   - Система отбрасывает несохраненные изменения
   - Возврат к шагу 7 основного сценария
5. Если пользователь выбирает "Cancel":
   - Действие прерывается
   - Конец юзер-кейса

**А3: Содержимое снапшота недоступно (на шаге 7)**
1. Система пытается прочитать содержимое снапшота из Local Storage
2. Файл с содержимым не существует или поврежден
3. Система отображает уведомление: "Failed to restore: snapshot content is missing or corrupted"
4. Система логирует ошибку для отладки
5. Файл не восстанавливается
6. Конец юзер-кейса

**А4: Ошибка записи файла (на шаге 9)**
1. Система пытается записать содержимое в файл
2. Происходит ошибка (нет прав доступа, диск переполнен и т.д.)
3. Система отображает уведомление: "Failed to restore file: <error message>"
4. Если была создана резервная копия, система предлагает восстановить ее
5. Файл не восстанавливается
6. Конец юзер-кейса

**А5: Файл был удален (на шаге 8)**
1. Система обнаруживает, что файл не существует на диске
2. Система создает новый файл с содержимым снапшота
3. Система отображает уведомление: "File recreated from snapshot"
4. Возврат к шагу 10 основного сценария

**Постусловия:**
- Файл восстановлен к состоянию из выбранного снапшота
- Текущая версия файла сохранена как резервная копия (если файл существовал)
- Создан новый снапшот для восстановленной версии
- Файл открыт в редакторе (если был открыт)

**Критерии приёмки:**
- ✅ Команда "Restore" доступна в контекстном меню Timeline
- ✅ Диалог подтверждения отображается перед восстановлением
- ✅ Несохраненные изменения обрабатываются корректно (сохранение или отбрасывание)
- ✅ Резервная копия создается перед восстановлением
- ✅ Ошибки чтения/записи обрабатываются с понятными сообщениями
- ✅ Восстановление работает для удаленных файлов (создание нового файла)
- ✅ История восстановления сохраняется (новый снапшот создается)

---

### UC-06: Скрытие элемента истории (Accept)

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Система (расширение changes_viewer)
- Local Storage
- Timeline view

**Предусловия:**
- UC-04 выполнен успешно (Timeline view отображает историю изменений)
- В Timeline view есть хотя бы один элемент с историей изменений
- Пользователь выбрал элемент снапшота из Timeline

**Основной сценарий:**
1. Пользователь просматривает Timeline view с историей изменений (результат UC-04)
2. Пользователь выбирает снапшот из списка
3. Пользователь использует команду "Accept" из контекстного меню или нажимает кнопку "Accept"
4. Система обновляет метаданные снапшота в Local Storage:
   - `accepted: true`
   - `acceptedTimestamp: Date.now()`
5. Система сохраняет обновленные метаданные в индекс
6. Система уведомляет Timeline API об изменении (если используется Timeline view)
7. Timeline view обновляется, и принятый снапшот исчезает из списка (скрывается)
8. Система отображает краткое уведомление: "Change accepted" (опционально, можно отключить)
9. Снапшот скрыт из списка истории

**Альтернативные сценарии:**

**А1: Снапшот уже принят (на шаге 4)**
1. Система проверяет метаданные снапшота
2. Система обнаруживает, что `accepted: true`
3. Система отображает уведомление: "This change is already accepted"
4. Или система позволяет "Unaccept" (отменить принятие):
   - `accepted: false`
   - `acceptedTimestamp: undefined`
5. Снапшот снова появляется в списке
6. Конец альтернативного сценария

**А2: Ошибка сохранения метаданных (на шаге 5)**
1. Система пытается сохранить обновленные метаданные в Local Storage
2. Происходит ошибка (нет прав доступа, диск переполнен и т.д.)
3. Система отображает уведомление: "Failed to accept change: <error message>"
4. Метаданные не обновляются, снапшот остается видимым
5. Конец юзер-кейса

**А3: Массовое принятие (расширенный сценарий)**
1. Пользователь выбирает несколько снапшотов (через Ctrl+Click / Cmd+Click)
2. Пользователь использует команду "Accept Selected"
3. Система обновляет метаданные для всех выбранных снапшотов
4. Все выбранные снапшоты скрываются из списка
5. Возврат к шагу 8 основного сценария

**Постусловия:**
- Метаданные снапшота обновлены (`accepted: true`)
- Снапшот скрыт из списка истории (не отображается в Timeline view)
- Снапшот остается в Local Storage (не удаляется, только скрывается)

**Критерии приёмки:**
- ✅ Команда "Accept" доступна в контекстном меню Timeline
- ✅ Принятые снапшоты скрываются из списка истории
- ✅ Принятые снапшоты остаются в Local Storage (не удаляются)
- ✅ Возможность отменить принятие ("Unaccept")
- ✅ Ошибки сохранения обрабатываются корректно
- ✅ Массовое принятие работает для нескольких выбранных снапшотов

---

### UC-07: Сравнение версии файла с текущей версией (Diff)

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Система (расширение changes_viewer)
- Diff-редактор VS Code
- Local Storage

**Предусловия:**
- UC-04 выполнен успешно (Timeline view отображает историю изменений)
- В Timeline view есть хотя бы один элемент с историей изменений
- Текущий файл открыт в редакторе или существует на диске
- Пользователь выбрал элемент снапшота из Timeline

**Основной сценарий:**
1. Пользователь просматривает Timeline view с историей изменений (результат UC-04)
2. Пользователь выбирает снапшот из списка
3. Пользователь использует команду "Compare with Current" из контекстного меню
4. Система получает содержимое выбранного снапшота из Local Storage
5. Система получает текущее содержимое файла:
   - Если файл открыт в редакторе, получает содержимое из редактора (включая несохраненные изменения)
   - Если файл не открыт, читает содержимое с диска
6. Система вычисляет diff между содержимым снапшота и текущим содержимым
7. Система открывает Diff-редактор VS Code:
   - Слева отображается содержимое снапшота (с меткой "Snapshot from <timestamp>")
   - Справа отображается текущее содержимое файла (с меткой "Current")
   - Изменения подсвечены стандартными цветами VS Code:
     * Зеленый фон - добавленные строки
     * Красный фон - удаленные строки
     * Желтый фон - измененные строки
8. Пользователь видит различия между версиями в Diff-редакторе

**Альтернативные сценарии:**

**А1: Выбранная версия идентична текущей (на шаге 6)**
1. Система сравнивает содержимое версий
2. Система обнаруживает, что версии идентичны (по хешу или содержимому)
3. Система отображает уведомление: "Selected version is identical to current file"
4. Diff-редактор не открывается
5. Конец юзер-кейса

**А2: Содержимое снапшота недоступно (на шаге 4)**
1. Система пытается прочитать содержимое снапшота из Local Storage
2. Файл с содержимым не существует или поврежден
3. Система отображает уведомление: "Failed to load snapshot content"
4. Diff-редактор не открывается
5. Конец юзер-кейса

**А3: Текущий файл не существует (на шаге 5)**
1. Система пытается прочитать текущий файл
2. Файл не существует на диске и не открыт в редакторе
3. Diff-редактор отображает:
   - Слева: содержимое снапшота
   - Справа: пустой файл или сообщение "File deleted"
4. Все строки помечены как удаленные
5. Возврат к шагу 8 основного сценария

**А4: Файл был удален в снапшоте, но существует сейчас (на шаге 6)**
1. Система обнаруживает, что снапшот является маркером удаления (`metadata.deleted: true`)
2. Diff-редактор отображает:
   - Слева: пустой файл или сообщение "File was deleted"
   - Справа: текущее содержимое файла
3. Все строки помечены как добавленные
4. Возврат к шагу 8 основного сценария

**Постусловия:**
- Diff-редактор открыт с отображением различий между версиями
- Пользователь может видеть все изменения между выбранной и текущей версией
- Изменения визуально выделены в редакторе

**Критерии приёмки:**
- ✅ Команда "Compare with Current" доступна в контекстном меню Timeline
- ✅ Diff-редактор корректно отображает различия между версиями
- ✅ Изменения визуально выделены стандартными цветами VS Code
- ✅ Обрабатываются случаи идентичных версий и недоступного содержимого
- ✅ Корректно обрабатывается случай удаленного файла (в снапшоте или текущей версии)
- ✅ Несохраненные изменения в редакторе учитываются при сравнении

---

### UC-08: Просмотр детальной информации о снапшоте

**Тип:** Новый Use Case

**Актёры:**
- Пользователь VS Code
- Система (расширение changes_viewer)
- Local Storage

**Предусловия:**
- UC-04 выполнен успешно (Timeline view отображает историю изменений)
- Пользователь выбрал элемент снапшота из Timeline

**Основной сценарий:**
1. Пользователь просматривает Timeline view с историей изменений
2. Пользователь выбирает снапшот из списка
3. Пользователь использует команду "Show Details" из контекстного меню или кликает на элемент
4. Система получает метаданные снапшота из Local Storage
5. Система отображает детальную информацию о снапшоте в панели или всплывающем окне:
   - **Основная информация:**
     * Дата и время создания
     * Источник создания (Typing, Save, External change, Manual)
     * Размер файла
     * Количество строк
   - **Информация об изменении (если доступна):**
     * Количество добавленных строк
     * Количество удаленных строк
     * Количество измененных строк
     * Предыдущий снапшот (ссылка)
   - **Техническая информация:**
     * ID снапшота
     * Content hash (SHA-256)
     * Путь к файлу содержимого
     * Статус принятия (Accepted / Not accepted)
6. Пользователь видит детальную информацию о снапшоте

**Альтернативные сценарии:**

**А1: Метаданные снапшота недоступны (на шаге 4)**
1. Система пытается прочитать метаданные снапшота
2. Метаданные не найдены или повреждены
3. Система отображает уведомление: "Failed to load snapshot details"
4. Детальная информация не отображается
5. Конец юзер-кейса

**Постусловия:**
- Детальная информация о снапшоте отображена пользователю
- Пользователь может видеть все метаданные снапшота

**Критерии приёмки:**
- ✅ Команда "Show Details" доступна в контекстном меню Timeline
- ✅ Детальная информация содержит все основные метаданные
- ✅ Информация об изменениях отображается, если доступна
- ✅ Техническая информация доступна для отладки
- ✅ Ошибки загрузки метаданных обрабатываются корректно

---

## 3. Нефункциональные требования

### 3.1. Производительность

#### 3.1.1. Создание снапшотов
- Создание снапшота при typing (с debounce) не должно блокировать ввод текста пользователем
- Время создания снапшота для файла до 1 MB: не более 100ms
- Время создания снапшота для файла до 10 MB: не более 500ms
- Debounce для typing: 2 секунды (настраиваемо)
- Debounce для FileSystemWatcher: 1 секунда (настраиваемо)

#### 3.1.2. FileSystemWatcher
- Обработка событий FileSystemWatcher не должна блокировать UI VS Code
- События обрабатываются асинхронно в фоновом режиме
- Фильтрация временных файлов выполняется до создания снапшота
- Максимальное количество одновременных операций создания снапшотов: 5

#### 3.1.3. Загрузка истории
- Загрузка списка снапшотов для файла (до 1000 снапшотов): не более 1 секунды
- Загрузка содержимого снапшота (до 10 MB): не более 500ms
- Пагинация: первые 50 снапшотов загружаются сразу, остальные - по требованию

#### 3.1.4. Восстановление файла
- Восстановление файла до 1 MB: не более 200ms
- Восстановление файла до 10 MB: не более 1 секунды

### 3.2. Безопасность
- Расширение не должно выполнять произвольные команды системы
- Доступ к файловой системе ограничен рабочей областью пользователя
- Снапшоты хранятся локально и не передаются во внешние системы
- Content hash (SHA-256) используется для проверки целостности снапшотов

### 3.3. Совместимость
- Расширение должно работать с VS Code версии 1.60.0 и выше
- Расширение должно быть совместимо с другими расширениями, использующими Timeline API
- Расширение должно работать на платформах: Windows, macOS, Linux
- Расширение должно корректно работать с различными кодировками файлов (UTF-8, UTF-16, и т.д.)

### 3.4. Масштабируемость
- Расширение должно корректно обрабатывать рабочие области с до 10,000 файлов
- Расширение должно корректно обрабатывать файлы до 50 MB (более крупные файлы могут быть пропущены)
- Максимальное количество снапшотов на файл: 100 (настраиваемо)
- Максимальный общий размер хранилища: 500 MB (настраиваемо)

### 3.5. Надежность
- Ошибки создания снапшотов не должны прерывать работу редактора
- Ошибки чтения/записи в Local Storage обрабатываются с повторными попытками
- Механизм восстановления после сбоя: проверка целостности индекса при запуске
- Логирование ошибок для отладки (без показа пользователю, если не критично)

---

## 4. Ограничения и допущения

### 4.1. Технические ограничения
- Расширение работает только с файлами в открытой рабочей области VS Code
- FileSystemWatcher может не отслеживать изменения на сетевых дисках (зависит от ОС)
- Максимальный размер файла для создания снапшота: 50 MB (настраиваемо)
- Снапшоты хранятся локально и не синхронизируются между устройствами
- Расширение не отслеживает изменения в файлах, которые были удалены из рабочей области

### 4.2. Бизнес-ограничения
- Расширение разрабатывается как open-source проект с лицензией MIT
- Первая версия фокусируется на базовой функциональности Local History
- Расширение не заменяет системы контроля версий (Git, SVN и т.д.), а дополняет их

### 4.3. Допущения
- Пользователь имеет базовое понимание работы с VS Code
- Рабочая область находится на локальном диске (не сетевой диск)
- Достаточно места на диске для хранения снапшотов (минимум 500 MB)
- Файлы в рабочей области не изменяются слишком часто (не более 100 изменений в секунду)

---

## 5. Открытые вопросы

Все критические вопросы из исходных требований решены. Остались следующие вопросы для уточнения:

### Вопрос 1: Использование Timeline API для отображения
**Контекст:** VS Code предоставляет Timeline API для отображения истории изменений в стандартном Timeline view.

**Проблема:** Следует ли использовать Timeline API для отображения Local History или создать собственный Custom View?

**Варианты решения:**
1. Использовать Timeline API (интеграция со стандартным интерфейсом VS Code)
2. Создать собственный Custom View (больше контроля над UI/UX)

**Рекомендация:** Использовать Timeline API для первой версии (быстрее реализация, стандартный интерфейс). При необходимости можно добавить Custom View в будущих версиях.

**Блокирует:** Определение архитектуры UI компонентов

---

### Вопрос 2: Стратегия хранения больших файлов
**Контекст:** Некоторые файлы могут быть очень большими (десятки мегабайт).

**Проблема:** Следует ли создавать снапшоты для больших файлов или пропускать их?

**Варианты решения:**
1. Пропускать файлы больше определенного размера (например, 10 MB)
2. Создавать снапшоты, но хранить только diff (различия)
3. Создавать снапшоты для всех файлов, но применять сжатие

**Рекомендация:** Пропускать файлы больше 50 MB (настраиваемо). Для файлов 10-50 MB применять сжатие.

**Блокирует:** Определение политики хранения

---

### Вопрос 3: Очистка старых снапшотов
**Контекст:** Со временем накапливается большое количество снапшотов.

**Проблема:** Когда и как очищать старые снапшоты?

**Варианты решения:**
1. Автоматическая очистка при достижении лимитов (LRU)
2. Периодическая очистка по расписанию (например, раз в день)
3. Ручная очистка через команду пользователя

**Рекомендация:** Комбинация: автоматическая очистка при достижении лимитов + периодическая очистка (раз в день) + команда для ручной очистки.

**Блокирует:** Определение механизма очистки

---

## Приложение A: Справочная информация

### A.1. VS Code Extension API - Ключевые интерфейсы

#### A.1.1. Отслеживание изменений в редакторе
```typescript
// Регистрация обработчика изменений документа
vscode.workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent) => {
  // event.document - измененный документ
  // event.contentChanges - массив изменений
});
```

#### A.1.2. FileSystemWatcher
```typescript
// Создание FileSystemWatcher
const watcher = vscode.workspace.createFileSystemWatcher(
  pattern: string | vscode.RelativePattern,
  ignoreCreateEvents?: boolean,
  ignoreChangeEvents?: boolean,
  ignoreDeleteEvents?: boolean
);

// Обработка событий
watcher.onDidCreate((uri: vscode.Uri) => { /* ... */ });
watcher.onDidChange((uri: vscode.Uri) => { /* ... */ });
watcher.onDidDelete((uri: vscode.Uri) => { /* ... */ });
```

#### A.1.3. Timeline API (для отображения)
```typescript
// Регистрация TimelineProvider
const timelineProvider = vscode.workspace.registerTimelineProvider(
  scheme: string | string[],
  provider: vscode.TimelineProvider
);

// Интерфейс TimelineProvider
interface TimelineProvider {
  provideTimeline(uri: vscode.Uri, options: TimelineOptions, token: CancellationToken): ProviderResult<Timeline>;
  onDidChange?: Event<TimelineChangeEvent>;
}
```

#### A.1.4. Extension Context Storage (Memento API)
```typescript
// Получение global storage
const globalState = context.globalState;

// Сохранение данных
await globalState.update('key', value);

// Чтение данных
const value = globalState.get('key', defaultValue);

// Получение пути к globalStorage
const storagePath = context.globalStoragePath; // путь к папке globalStorage
```

### A.2. Архитектура хранения данных

#### A.2.1. Структура папок
```
globalStorage/
  └── changes_viewer/
      ├── snapshots.json          # Индекс всех снапшотов
      └── snapshots/              # Папка с содержимым снапшотов
          └── <fileHash>/         # Папка для каждого файла (по хешу пути)
              ├── <snapshotId>.txt  # Содержимое снапшота
              └── ...
```

#### A.2.2. Формат файла snapshots.json
```json
{
  "version": "1.0",
  "snapshots": [
    {
      "id": "uuid-1",
      "fileUri": "file:///path/to/file.txt",
      "filePath": "/absolute/path/to/file.txt",
      "timestamp": 1234567890,
      "source": "typing",
      "contentHash": "sha256-hash",
      "contentPath": "snapshots/fileHash/uuid-1.txt",
      "metadata": {
        "lineCount": 100,
        "size": 5000
      },
      "accepted": false
    }
  ],
  "index": {
    "file:///path/to/file.txt": ["uuid-1", "uuid-2"]
  }
}
```

### A.3. Алгоритм дедупликации
1. При создании снапшота вычисляется SHA-256 хеш содержимого файла
2. Система проверяет contentHash последнего снапшота для этого файла
3. Если хеши совпадают, новый снапшот не создается
4. Если хеши различаются, создается новый снапшот

### A.4. Алгоритм очистки (LRU)
1. При достижении лимита количества снапшотов на файл (100):
   - Находятся все снапшоты для файла
   - Сортируются по timestamp (старые первыми)
   - Удаляются самые старые снапшоты до достижения лимита
2. При достижении лимита общего размера хранилища (500 MB):
   - Вычисляется размер каждого снапшота
   - Снапшоты сортируются по времени последнего доступа (LRU)
   - Удаляются наименее используемые снапшоты до освобождения места
3. Периодическая очистка по TTL (90 дней):
   - Находятся все снапшоты старше 90 дней
   - Удаляются, если они не были приняты (accepted: false) или не использовались
